---
title: 浅谈数据加密、https
description: 生活中商业化的加密方式主要包括AES加密、RSA加密、MD5加密
date: 2024-08-01
lang: zh
---

## 数据加密
假设小客给小服发了一句 hello，并且他们制定了一个加密规则，那就是对他们之间的聊天进行加密，以防止聊天消息被窃取和篡改，这个加密规则是：把明文中的每一个字母后移一位，生成密文，这样就生成了密文：ifmmp，显然若信件途中被拦截下来，拦截者是看不懂内容的，如果它对内容进行篡改，小服拿到密文把每一位字母前移一位，会发现不是正常的单词，就会发觉信息已被篡改。

但是生活中商业化的加密方式肯定比上述复杂得多，以下列举几个比较常用的加密方式

#### 对称加密
如AES、DES加密，对称加密的意思是加密和解密的密钥都是一样的，例如使用密钥12345对字符串进行加密，那就需要使用密钥12345对这个字符串解密以获得明文，密钥就像是钥匙一样，可以加锁，也可以解锁。

#### 非对称加密
如RSA、ECC椭圆曲线加密算法，非对称加密需要两个密钥(一对密钥)，公钥：公开密钥，私钥：私有密钥，使用公钥对数据进行加密，只能使用对应的私钥才能解锁，私钥是保密的，公钥是公开的。

#### Hash算法
如MD5、SHA，MD5使用较为广泛，它可以将一个任意长度的字符串生成16字节的散列值，不同的字符串，哪怕只有一个字母不同，他们的散列值都是完全不同的，相同的字符串有相同的散列值，并且无法根据散列值倒推回原来的明文，但是因为使用MD5生成的密文与明文一一对应，因此只要知道这一对明文和密文，就可以轻松根据密文推出明文，如“123”MD5加密后为的32位密文为“202cb962ac59075b964b07152d234b70”，那已知密文“202cb962ac59075b964b07152d234b70”即可推出它的明文为123，即使近年已证明MD5已被攻破，并推出了MD6，但目前而言，MD5仍被广泛用于密码不可逆加密，请求验签等。


## 数据加密示例
#### AES加密
已知明文{"data":"hello"}，且客户端与服务端私下约定好key为12345，则使用AES加密出来的密文为(U2FsdGVkX189vc7hUqp6f8FhQMMUMI9GFiWOtChSEM3u4jDRLDJiwm6lee3MjmqT)，则拦截者必须知道双方约定好的密钥才能获得明文，如果拦截者对密文进行篡改，服务端则无法正常解析，篡改内容不会被信任。

#### RSA加密
已知明文{"data":"hello"}，客户端保存这公钥12345，服务端保存私钥09876，则使用公钥加密的密文只能通过私钥来解密，且由于公钥可以根据私钥计算出来，因此理论上只需要私钥就可以进行加解密，但是由于很多情况下私钥放在客户端并不安全，因此一般是客户端存放公钥，服务端存放私钥。

#### MD5加密
由于MD5加密是不可逆的，因此一般不会直接对数据进行加密，因为客户端使用MD5对整个数据进行加密了，服务端也无法获取明文，因此MD5加密一般用于用户密码加密和验签，为了提高MD5的安全性，一般在使用MD5的时候会进行“加盐”操作，例如明文是12345，盐是sajhdakj，那么实际上就是将12345sajhdakj进行MD5加密，这样攻击者很难通过密文倒推出明文，如今很多网站都可以解密MD5，实际上绝大多数都是存储着明文和密文的键值对，以便第一时间通过密文倒推明文。

#### 用户密码加密
假设用户进行登录操作，发送请求{"account":"123","pwd":"456"}，若此请求被攻击者拦截，攻击者可以轻松获得其密码并登录其账号，更为严重的事，很多用户不同平台使用的密码相同，这样就会极大地危害用户信息安全，因此一般都会对用户的密码“456”进行加盐的MD5操作，这样攻击者拿到密文无法推出明文，也就保证了用户的账户安全，对于服务端来说，其实没有必要得知用户密码的明文，只要在注册的时候将用户密码的密文存到数据库中，在用户登录的时候比较密文即可。因此大多数网站都无法提供密码找回服务（因为他们也不知道用户的密码明文是什么），只能提供密码重置服务。

#### 请求验签 
假设用户进行登录操作，发送请求{"account":"123","pwd":"456"}，通过将json转化为特定的格式，如account=123&pwd=456(一般会拼接一段固定的字符串【盐】)，并对其进行md5加密，将加密后的MD5值放在sign字段中，就得到{"account":"123","pwd":"456","sign":"MD5加密后的值"}，服务器拿到这个json的时候，将sign以外的key和value进行与客户端相同的加密操作，并比对加密出来的结果与sign内容的值，若相同，则可以认为account和pwd未被篡改，可信任这个请求，若不同，则代表必然有信息被篡改，则废弃这个请求。

## https
https是指http+SSL/TLS协议，在传输过程中对数据进行加密，开发者无法自己设定加密逻辑

### https加密大致流程
服务端与客户端通过https进行通讯，数据加密使用到了非对称加密(一般是RSA)和对称加密，大致流程如下：

1. 客户端向服务端发起https请求。
2. 服务端将之前生成的一对RSA密钥中的公钥返回给客户端。
3. 客户端随机生成一个对称加密(如AES)的key(密钥)，并通过服务器提供的RSA公钥，对这个key进行加密，将加密后的对称加密key发送给服务端。
4. 服务端拿到这个对称加密后的key，并通过自己的私钥对这个密文进行解密，拿到与客户端进行对称加密通讯的明文key。
5. 服务端与客户端通过这个key加密密文进行通信。

### 疑问
为什么这个流程这么繁琐，服务端直接把对称加密的密钥给客户端不就可以了吗？答：服务端把对称加密密钥给客户端的途中，可能被中间人拦截，中间人获得对称加密的key之后，加密形同虚设。

上述流程真的就万无一失了吗？显然还有很大的漏洞！服务端将RSA非对称加密的公钥发送给客户端的途中，中间人可以将公钥拦截下来，并提前自己创建一对RSA密钥，将自己的RSA公钥发送给客户端，客户端通过这个被篡改的RSA公钥对自己随机生成的对称加密密钥进行加密后，发送给服务端，在这个途中，中间人可以将此密文拦截下来，并通过自己的RSA私钥进行解密(因为客户端实际上是用自己的公钥加密的)，此时中间人可以拿到明文的对称加密密钥，此时中间人通过先前截获的服务端的RSA公钥对此对称密钥进行加密，并发送给服务端，服务端通过自己的RSA私钥可以获取到对称加密密钥的明文，此时中间人已经悄悄获取了二者将来进行的对称加密通讯的密钥，就可以轻松解密和篡改二者的通讯信息了。

### 如何解决上述问题
实际上https通讯过程中还有一个极为重要的角色：CA(Certificate Authority)数字证书颁发机构，CA实际上是指多个权威的证书颁发机构，他们会生成一对公钥和私钥，并将公钥存储于操作系统和浏览器中，通过CA的介入可以完美解决，CA介入以后的加密流程如下：

1. 客户端向服务端发起https请求。
2. 服务端将之前生成的一对RSA密钥中的公钥(通过CA的RSA私钥加密后)，返回给客户端。
3. 客户端拿到加密后的服务器公钥，通过浏览器或系统中预先安装好的公钥进行解密，若可以解密，则https请求可以继续进行，客户端顺利拿到服务器公钥的明文，并使用这个公钥对随机生成的对称加密密钥加密，将加密后的对称加密key发送给服务端。若无法解密，则代表公钥被篡改，https请求终止，且浏览器会显示warning。
4. 服务端拿到这个对称加密后的key，并通过自己的私钥对这个密文进行解密，拿到与客户端进行对称加密通讯的明文key。
5. 服务端与客户端通过这个key加密密文进行通信。
6. 此时这个加密后的公钥若被中间人拦截，并且由于CA的公钥是公开的，因此中间人可以解密并获取服务器的公钥明文，但是他无法将其替换为自己的公钥，因为替换之后，他需要CA的私钥来对自己的公钥来进行加密，否则直接将明文的公钥或者是使用他人私钥加密后的公钥提交给客户端，由于客户端中没有可以解密的公钥，https请求将终止。
